"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.upgradeContracts = main;
exports.checkProxyStatus = checkProxyStatus;
exports.validateStorageLayout = validateStorageLayout;
const hardhat_1 = require("hardhat");
const fs_1 = require("fs");
const path_1 = require("path");
/**
 * Comprehensive Contract Upgrade Script for Tachi Protocol
 *
 * This script handles UUPS proxy upgrades with validation, verification,
 * and comprehensive testing of the upgraded contracts.
 */
async function main() {
    const [deployer] = await hardhat_1.ethers.getSigners();
    function log(message) {
        console.log(message);
    }
    log(`\nüîÑ Upgrading Tachi Protocol Contracts on ${hardhat_1.network.name}...`);
    log(`üìã Deployer: ${deployer.address}`);
    log("=".repeat(60));
    // Load existing deployment info
    const deploymentFile = (0, path_1.join)("deployments", `${hardhat_1.network.name}-upgradeable.json`);
    let existingDeployment;
    try {
        existingDeployment = JSON.parse((0, fs_1.readFileSync)(deploymentFile, "utf8"));
        log(`‚úÖ Loaded deployment info from: ${deploymentFile}`);
    }
    catch (error) {
        log(`‚ùå Could not load existing deployment from ${deploymentFile}`);
        log(`Please run deploy script first: pnpm run deploy:upgradeable`);
        process.exit(1);
    }
    try {
        const currentCrawlNFTAddress = existingDeployment.contracts.CrawlNFTUpgradeable.proxy;
        const currentPaymentProcessorAddress = existingDeployment.contracts.PaymentProcessorUpgradeable.proxy;
        // Phase 1: Import existing proxies for upgrade tracking
        log("\nüì¶ PHASE 1: Importing Existing Proxy Deployments");
        log("-".repeat(50));
        log("üîó Importing CrawlNFT proxy...");
        const CrawlNFTFactory = await hardhat_1.ethers.getContractFactory("CrawlNFTUpgradeable");
        await hardhat_1.upgrades.forceImport(currentCrawlNFTAddress, CrawlNFTFactory, {
            kind: "uups"
        });
        log("‚úÖ CrawlNFT proxy imported successfully");
        log("üîó Importing PaymentProcessor proxy...");
        const PaymentProcessorFactory = await hardhat_1.ethers.getContractFactory("PaymentProcessorUpgradeable");
        await hardhat_1.upgrades.forceImport(currentPaymentProcessorAddress, PaymentProcessorFactory, {
            kind: "uups"
        });
        log("‚úÖ PaymentProcessor proxy imported successfully");
        // Phase 2: Validate upgrades
        log("\nüîç PHASE 2: Validating Upgrade Compatibility");
        log("-".repeat(50));
        log("üîç Validating CrawlNFT upgrade...");
        await hardhat_1.upgrades.validateUpgrade(currentCrawlNFTAddress, CrawlNFTFactory, {
            kind: "uups"
        });
        log("‚úÖ CrawlNFT upgrade validation passed");
        log("üîç Validating PaymentProcessor upgrade...");
        await hardhat_1.upgrades.validateUpgrade(currentPaymentProcessorAddress, PaymentProcessorFactory, {
            kind: "uups"
        });
        log("‚úÖ PaymentProcessor upgrade validation passed");
        // Phase 3: Execute upgrades
        log("\n‚¨ÜÔ∏è PHASE 3: Executing Contract Upgrades");
        log("-".repeat(50));
        log("‚¨ÜÔ∏è Upgrading CrawlNFTUpgradeable...");
        const upgradedCrawlNFT = await hardhat_1.upgrades.upgradeProxy(currentCrawlNFTAddress, CrawlNFTFactory);
        await upgradedCrawlNFT.waitForDeployment();
        log(`‚úÖ CrawlNFT upgraded successfully at: ${currentCrawlNFTAddress}`);
        log("‚¨ÜÔ∏è Upgrading PaymentProcessorUpgradeable...");
        const upgradedPaymentProcessor = await hardhat_1.upgrades.upgradeProxy(currentPaymentProcessorAddress, PaymentProcessorFactory);
        await upgradedPaymentProcessor.waitForDeployment();
        log(`‚úÖ PaymentProcessor upgraded successfully at: ${currentPaymentProcessorAddress}`);
        // Phase 4: Get new implementation addresses
        log("\nüèóÔ∏è PHASE 4: Implementation Address Tracking");
        log("-".repeat(50));
        const newCrawlNFTImpl = await hardhat_1.upgrades.erc1967.getImplementationAddress(currentCrawlNFTAddress);
        const newPaymentProcessorImpl = await hardhat_1.upgrades.erc1967.getImplementationAddress(currentPaymentProcessorAddress);
        log(`üèóÔ∏è New CrawlNFT Implementation: ${newCrawlNFTImpl}`);
        log(`üèóÔ∏è New PaymentProcessor Implementation: ${newPaymentProcessorImpl}`);
        // Phase 5: Verify contracts on block explorer (if not local)
        if (hardhat_1.network.name !== "hardhat" && hardhat_1.network.name !== "localhost") {
            log("\nüîç PHASE 5: Verifying Implementation Contracts");
            log("-".repeat(50));
            try {
                log("üîç Verifying CrawlNFT implementation...");
                await (0, hardhat_1.run)("verify:verify", {
                    address: newCrawlNFTImpl,
                    constructorArguments: [],
                });
                log("‚úÖ CrawlNFT implementation verified");
                log("üîç Verifying PaymentProcessor implementation...");
                await (0, hardhat_1.run)("verify:verify", {
                    address: newPaymentProcessorImpl,
                    constructorArguments: [],
                });
                log("‚úÖ PaymentProcessor implementation verified");
            }
            catch (error) {
                log(`‚ö†Ô∏è Contract verification failed: ${error}`);
                log("‚ÑπÔ∏è Manual verification may be required on block explorer");
            }
        }
        else {
            log("\n‚è≠Ô∏è PHASE 5: Skipping verification (local network)");
        }
        // Phase 6: Test upgraded contracts
        log("\nüß™ PHASE 6: Testing Upgraded Contracts");
        log("-".repeat(50));
        // Test CrawlNFT functionality
        log("üß™ Testing CrawlNFT functionality...");
        const crawlNFT = await hardhat_1.ethers.getContractAt("CrawlNFTUpgradeable", currentCrawlNFTAddress);
        const name = await crawlNFT.name();
        const symbol = await crawlNFT.symbol();
        const owner = await crawlNFT.owner();
        log(`ÔøΩ CrawlNFT Name: ${name}`);
        log(`üè∑Ô∏è CrawlNFT Symbol: ${symbol}`);
        log(`üëë CrawlNFT Owner: ${owner}`);
        // Test PaymentProcessor functionality
        log("üß™ Testing PaymentProcessor functionality...");
        const paymentProcessor = await hardhat_1.ethers.getContractAt("PaymentProcessorUpgradeable", currentPaymentProcessorAddress);
        const usdcToken = await paymentProcessor.usdcToken();
        const crawlNFTContract = await paymentProcessor.crawlNFTContract();
        const baseCrawlFee = await paymentProcessor.baseCrawlFee();
        log(`ÔøΩ PaymentProcessor USDC: ${usdcToken}`);
        log(`ÔøΩ Linked CrawlNFT: ${crawlNFTContract}`);
        log(`ÔøΩ Base Crawl Fee: ${baseCrawlFee} USDC`);
        // Phase 7: Update deployment record
        log("\nÔøΩ PHASE 7: Updating Deployment Records");
        log("-".repeat(50));
        const updatedDeployment = {
            ...existingDeployment,
            lastUpgrade: {
                timestamp: new Date().toISOString(),
                upgrader: deployer.address,
                previousImplementations: {
                    CrawlNFT: existingDeployment.contracts.CrawlNFTUpgradeable.implementation,
                    PaymentProcessor: existingDeployment.contracts.PaymentProcessorUpgradeable.implementation,
                },
            },
            contracts: {
                ...existingDeployment.contracts,
                CrawlNFTUpgradeable: {
                    proxy: currentCrawlNFTAddress,
                    implementation: newCrawlNFTImpl,
                },
                PaymentProcessorUpgradeable: {
                    proxy: currentPaymentProcessorAddress,
                    implementation: newPaymentProcessorImpl,
                },
            },
        };
        (0, fs_1.writeFileSync)(deploymentFile, JSON.stringify(updatedDeployment, null, 2));
        log(`‚úÖ Deployment record updated: ${deploymentFile}`);
        // Final Summary
        log("\n" + "=".repeat(60));
        log("üéâ CONTRACT UPGRADE COMPLETED SUCCESSFULLY!");
        log("=".repeat(60));
        log(`üìã Network: ${hardhat_1.network.name}`);
        log(`üé´ CrawlNFT Proxy: ${currentCrawlNFTAddress}`);
        log(`üèóÔ∏è CrawlNFT Implementation: ${newCrawlNFTImpl}`);
        log(`üí≥ PaymentProcessor Proxy: ${currentPaymentProcessorAddress}`);
        log(`üèóÔ∏è PaymentProcessor Implementation: ${newPaymentProcessorImpl}`);
        log(`üë§ Upgraded by: ${deployer.address}`);
        log(`‚è∞ Upgrade completed: ${new Date().toISOString()}`);
        log("=".repeat(60));
        log("\n‚úÖ All contracts successfully upgraded and tested!");
        log("‚ÑπÔ∏è State preservation verified, new functionality available");
    }
    catch (error) {
        log(`\n‚ùå UPGRADE FAILED: ${error}`);
        log("\nüîß Troubleshooting steps:");
        log("1. Check that contracts are deployed: pnpm run deploy:upgradeable");
        log("2. Verify network configuration is correct");
        log("3. Ensure deployer has sufficient permissions");
        log("4. Check storage layout compatibility");
        throw error;
    }
}
/**
 * Utility function to check if a proxy exists and is upgradeable
 */
async function checkProxyStatus(proxyAddress, contractName) {
    try {
        const implementationAddress = await hardhat_1.upgrades.erc1967.getImplementationAddress(proxyAddress);
        console.log(`‚úÖ ${contractName} proxy found with implementation: ${implementationAddress}`);
        return true;
    }
    catch (error) {
        console.log(`‚ùå ${contractName} proxy not found or not upgradeable: ${error}`);
        return false;
    }
}
/**
 * Utility function to validate storage layout compatibility
 */
async function validateStorageLayout(proxyAddress, newImplementationName) {
    try {
        const NewImplementation = await hardhat_1.ethers.getContractFactory(newImplementationName);
        await hardhat_1.upgrades.validateUpgrade(proxyAddress, NewImplementation, { kind: "uups" });
        return true;
    }
    catch (error) {
        console.log(`‚ùå Storage layout validation failed: ${error}`);
        return false;
    }
}
// Run the upgrade
if (require.main === module) {
    main()
        .then(() => {
        console.log("\nüéâ Upgrade script completed successfully!");
        process.exit(0);
    })
        .catch((error) => {
        console.error("\nüí• Upgrade script failed:", error);
        process.exit(1);
    });
}
